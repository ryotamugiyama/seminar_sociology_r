# 回帰分析の活用 {#regression_advanced}

本章では、前章で学んだ回帰分析を発展させて、複数の独立変数を扱う方法について説明する。

内容に入る前に、右上のプロジェクトのボックスの横が、前章で作成したプロジェクトの名前（たとえば、seminar_sociology_r）になっているかどうかを確認しておこう。なっていない場合は、右上のボックスをクリックして、「Open Project...」を選択し、前章で作成したRprojファイル（たとえば、seminar_sociology_r.Rprojといったような名前になっている）を選んで、プロジェクトを切り替えよう。

さらに、これまでの章で説明した以下のパッケージを読み込んだ上で、[第4章](#handling)で作成したデータを読み込んで`piaac`というデータフレームに入れていることを前提とする。具体的には、以下のコードを実行しておく必要がある。

```{r}
library(tidyverse)
library(gtsummary)
library(flextable)
library(modelsummary)
library(broom)

piaac <- read_rds("data/piaac_sample_analytic.rds")
```

[第5章で確認したように](#descriptives_ggplot)、ggplotの設定を変更しておくことで見やすいグラフを作ることができる。ここでは以下のコードを実行している。

Macの場合：

```{r}
theme_set(theme_bw(
  base_family = "HiraginoSans-W3",
  base_size = 11,
  base_rect_size = 0.2,
  base_line_size = 0.2
))
```

Windowsの場合：

```{r, eval = FALSE}
theme_set(theme_bw(
  base_size = 11,
  base_rect_size = 0.2,
  base_line_size = 0.2
))
```

## 重回帰分析

先の単回帰分析では、年齢、性別、学歴、数的思考力スコアによって賃金が異なっていることをみた。これら4つの変数を同時に考慮することで、賃金の分散をよりよく説明できるモデルを作ることができないだろうか？このようなときに役に立つのが、**重回帰分析**である。

今推定したい式は次のように書くことができる。

$$
y = \beta_0 + \beta_1年齢 + \beta_2女性 + \beta_3高校卒 + \beta_4短大高専卒 + \beta_5大学大学院卒 + \beta_6数的思考力スコア
$$

$\beta_1$が年齢の係数、$\beta_2$が（男性と比較したときの）女性の係数、$\beta_3, \beta_4, \beta_5$が（中学卒と比較したときの）高校卒、短大高専卒、大学大学院卒の係数を、$\beta_6$が数的思考力スコアの係数を、それぞれ表す。各係数は、**他の変数を一定として**（**統制 control**して、ともいう）、当該変数が1単位高いと$y$がどれだけ高いのか、という独立の影響力を測っていることになる。

単回帰分析のときと同じように、`lm()`関数を使って推定することができる。ここでは、賃金の測定の際により一般的に使われる、対数変換した賃金（logwage）を用いる。正負の解釈については通常と同じだが、係数の値についての解釈は少しだけ勉強が必要になる。くわしくは前章「[対数変換](#regression_basic_log)」を参照のこと。

```{r}
reg_res <- lm(data = piaac, logwage ~ age + gender + educ + numeracy)
summary(reg_res)
```

それぞれ係数、標準誤差、p値のみかたはいずれも前回と同じである。

一般的に、重回帰分析の式は次のように書ける。

$$
y = \beta_0 + \beta_1x_1 + \beta_2x_2 + \cdots + \beta_kx_k
$$

係数$\beta_1$は、他の変数$x_2, \cdots, x_k$を一定としたうえで、$x_1$が1単位高いと$y$がどれだけ高いのかを示す。

重回帰分析の係数はやはり最小二乗法によって推定される。

## 交絡要因の統制

### 交絡とは何か

では実際、重回帰分析はどのようなことを知りたいときに使うのだろうか。たとえば、高い数的思考力スコアが高いとどれくらい対数賃金が高くなるのかを知りたいと思ったとする。もっともシンプルな方法が、前回みたように（単）回帰分析を使う方法である。

しかしこの方法では、数的思考力スコアの**効果**を知るには不十分である。一つの例を考えよう。たとえば、女性はさまざまな理由から男性と比べて数的思考力スコアが低い傾向がある[^08-regression_advanced-1]。また、女性はさまざまな理由から労働市場で男性と比べて高い賃金を得られていない。だとすれば、数的思考力スコアが高いと賃金が高いというのはたんに見かけ上の関係に過ぎず、実際には数的思考力スコアは何ら賃金を高める効果を持っていないのかもしれない。性別に色分けした以下の散布図を見てみよう。たしかに、数的思考力も高く対数賃金も高い右上には男性が、数的思考力スコアが低く対数賃金も低い左下には女性が、それぞれ集中しているようにみえる。

[^08-regression_advanced-1]: たとえば女性は男性と同等の数学能力を持っていたとしても、男性と比べて数学を使う分野（理系など）に進みにくい傾向がある。このような傾向があると、小中学校の間は男女で数的思考力に違いがなかったとしても、高校、大学と段階が進むにつれて数学に触れる時間に差が生じ、結果、男女の数的思考力に差が生じる。こうした傾向については数多くの研究がある（たとえば、Xie, Yu and Kimberlee A. Shauman. 2005. *Women in Science: Career Processes and Outcomes.* Harvard University Press.など）。

```{r}
piaac %>% 
  ggplot(aes(x = numeracy, y = logwage, color = gender)) + 
  geom_point(shape = 1) +
  labs(color = "")
```

性別を**一定としたうえで**、言い換えれば、性別が同じであったとしてもなお、数的思考力スコアと（対数）賃金の関係をみることができたなら、「数的思考力スコアはどの程度賃金を高める効果を持つのか」という問いの答えに近づくことができる。重回帰分析は、こうしたモチベーションに答えるための方法である。

今の議論を図にすると、次のようなかたちになる。

```{r, echo=FALSE}
dag_1 <- dagitty("dag{X -> Y; Z -> X; Z -> Y}")
coordinates(dag_1) <- list(x = c(X = 0, Z = 1, Y = 2),
                           y = c(X = 0, Z = 1, Y = 0))
dag_1 %>% 
  tidy_dagitty() %>% 
  ggdag() + 
  theme_dag()
```

Xを数的思考力スコア、Yを賃金、Zを性別と考えよう。知りたいのは数的思考力スコアが賃金に与える効果（X → Y）だが、その背後にはXにもYにも影響する要因Z（Z → X、Z → Y）が存在する。そのため、数的思考力スコアが賃金に与える効果をみたいのならば、Zを一定とする必要がある。このように、XとYの両者に影響する要因を**交絡要因 confounder**とよぶ。

複数の変数を使うときの回帰分析では、関心のある変数xと、統制したい変数zというふうに別々の役割があるということが多い。

### 結果の比較と解釈

もちろん、両者の背後にある交絡要因は性別だけではないだろう。年齢や学歴も関係しているかもしれない。たとえば学歴はどのように数的思考力スコアと賃金の両者と関係しているだろうか。学歴が高い人は学校での勉強を通じて数的思考力スコアを高めており、学歴が高い人は（本人の能力とは関係なしに）賃金の高い仕事に就けるために、見かけ上数的思考力スコアと賃金に正の関連があるだけかもしれない。

以下では、

1.  単回帰分析
2.  性別を統制した回帰分析
3.  性別に加えてさらに年齢と学歴を統制した回帰分析

を比較しながら、それぞれ数的思考力スコアの係数がどのように変わるのかをみてみよう。

```{r}
reg_res1 <- lm(data = piaac, logwage ~ numeracy)
reg_res2 <- lm(data = piaac, logwage ~ numeracy + gender)
reg_res3 <- lm(data = piaac, logwage ~ numeracy + gender + age + educ)

modelsummary(list(reg_res1, reg_res2, reg_res3),
         stars = TRUE, 
         fmt = 4,
         coef_map = c("numeracy" = "数的思考力スコア",
                      "age" = "年齢",
                      "gender男性" = "男性（vs. 女性）",
                      "educ高校" = "高校（vs. 中学）",
                      "educ短大高専" = "短大高専（vs. 中学）",
                      "educ大学大学院" = "大学大学院（vs. 中学）",
                      "(Intercept)" = "切片"), 
         gof_map = c("nobs", "r.squared"))
```

なお、この例のように、回帰分析の表を作るときには、カテゴリ変数の比較対象（参照カテゴリ）が何かを書くとわかりやすいだろう。

また、一般的に切片の値そのものにはあまり興味がないことが多いので、切片の係数は下の方に表示されることが多い。`coef_map = c()`の箇所に表記した順番に係数が表示されるので、ここの順番を調整すると、切片の係数を下の方に表示することができる。

```{r, echo = FALSE}
reg_res2_tidy <- tidy(reg_res2) %>% 
  mutate(estimate = round(estimate, digits = 0))
```

Model 1、Model 2、Model 3ではそれぞれ数的思考力スコアの係数が違っていることが確認できる。性別を統制したModel 2、さらに年齢と学歴を統制したModel 3では、それぞれ係数が小さくなっていることがわかる。ここからわかることは2つである。第1に、数的思考力スコアと対数賃金との正の関連の一部は、両者の背後にある交絡要因（性別、年齢、学歴）によって生じているということである。第2に、しかしながらこれらの交絡要因を統制してもなお、数的思考力スコアの係数は正でありかつ統計的にも有意である。したがって、性別、年齢、学歴を一定としてもなお、数的思考力スコアが高いほど対数賃金が高いといえる。

もちろん、性別や年齢、学歴だけではなくほかにもさまざまな要因が絡んでくるから、これだけで数的思考力が賃金に与える効果の真の推定値を明らかにしたのだということはできない。しかし、適切に要因を統制すれば、数的思考力が賃金を高めるという効果の真の推定値に近づいていくことはできる。

## 媒介分析／要因分解

女性は男性と比べて賃金が低い（男女間賃金格差がある）のはなぜなのかを知りたいとする。たとえばその原因には、(1) 女性が男性よりも教育水準（学歴）が低い、(2) 女性が男性よりも数的思考力スコアが低い、ということがありえるだろう。このような原因を調べるというときにも、重回帰分析を活用することができる。

性別をX、賃金をY、学歴および数的思考力スコアをMとすると、ここでのアイデアは次のような図に表すことができる。

```{r, echo=FALSE}
dag_1 <- dagitty("dag{X -> Y; X -> M; M -> Y}")
coordinates(dag_1) <- list(x = c(X = 0, M = 1, Y = 2),
                           y = c(X = 0, M = 1, Y = 0))
dag_1 %>% 
  tidy_dagitty() %>% 
  ggdag() + 
  theme_dag()
```

性別が賃金に与える効果は、(1) 女性の学歴や数的思考力スコアが低く、したがって賃金も低い（X → M → Y）という部分と、(2) 学歴や数的思考力スコアを一定としてもなお女性のほうが賃金が低い（X → Y \| M）という部分とに分けることができる。このようにして、XとYの中間にある要因（**媒介要因 mediator**）を考えることでグループ間の差や独立変数の効果を分けていくことを指して、**媒介分析 mediation analysis**や**要因分解decomposition**などという。

```{r}
piaac <- piaac %>% 
  mutate(female_d = if_else(gender == "女性", 1, 0))

reg_res1 <- lm(data = piaac, logwage ~ female_d)
reg_res2 <- lm(data = piaac, logwage ~ female_d + educ + numeracy)

modelsummary(list(reg_res1, reg_res2),
                  stars = TRUE, 
         coef_map = c("female_d" = "女性（vs. 男性）",
                      "educ高校" = "高校（vs. 中学）",
                      "educ短大高専" = "短大高専（vs. 中学）",
                      "educ大学大学院" = "大学大学院（vs. 中学）",
                      "numeracy" = "数的思考力スコア",
                      "(Intercept)" = "切片"), 
         gof_map = c("nobs", "r.squared"))
```

```{r, echo = FALSE}
reg_res1_tidy <- tidy(reg_res1) %>% 
  mutate(estimate = round(estimate, digits = 0))
reg_res2_tidy <- tidy(reg_res2) %>% 
  mutate(estimate = round(estimate, digits = 0))
```

Model 1では、女性ダミーの係数は負であるので、女性は男性に比して賃金が低いということがわかる。

Model 2では、学歴と数的思考力スコアを追加している。高校、短大高専、大学大学院の係数はいずれも正であり、学歴が高いほど、賃金は高い傾向がある。また、数的思考力スコアも正であり、数的思考力スコアが高いほど賃金が高い傾向がある。これら学歴と数的思考力スコアを一定とすると、女性ダミーの係数は`r reg_res2_tidy$estimate[2]`となり、Model 1の女性の係数（`r reg_res1_tidy$estimate[2]`）よりも絶対値が小さくなっている（0に近づいている）ことがわかる。ただし係数はなお負で、統計的に有意である。

この結果は次のことを意味している。女性の賃金が低いことの一部は、女性は男性と比べて学歴が低いことや、数的思考力スコアが低いことによって説明できる。しかしながら同時に、これらの個人属性を一定としてもなお、男女間には大きな賃金格差が存在している。

## 回帰分析の実際

実際の論文では、交絡要因の統制と媒介分析の両方を考慮しながら分析されることが多い。すなわち、次のような図になる。

```{r, echo=FALSE}
dag_1 <- dagitty("dag{X -> Y; Z -> X; Z -> Y; X -> M; M -> Y}")
coordinates(dag_1) <- list(x = c(X = 0, Z = 1, M = 1, Y = 2),
                           y = c(X = 0, Z = 1, M = -1, Y = 0))
dag_1 %>% 
  tidy_dagitty() %>% 
  ggdag() + 
  theme_dag()
```

たとえば、学歴が高いと賃金が高い（X → Y）のはなぜなのか知りたいとする。その原因の1つとして、学歴が高いとよりスキルレベルが高い（賃金の高い）職業につくことができるから（X → M → Y）、ということが考えられる。実際、学歴別に職業の分布を比べてみると、学歴が高いほど管理職や専門職といったスキルレベルの高い職業に就いている傾向があることがわかる。

```{r}
piaac %>% 
  tbl_cross(educ, occupation, percent = "row")
```

先に確認したように、学歴と賃金の間には性別や年齢といった交絡要因が存在する（Z → X, Z → Y）。なので、あらかじめこれらを統制しておいたうえで、学歴による賃金の差が職業の違いによってどの程度説明されるのかというのをみる必要がある。

実際の分析結果は次のようになる。賃金については実額よりも対数を取った値のほうがよく使われるので、従属変数は対数賃金とする。また賃金を従属変数とする回帰分析の場合、年齢の2乗も考慮することが多いので、2乗項についても投入しよう。

```{r}
reg_res1 <- lm(data = piaac, logwage ~ educ + gender + age + I(age^2))
reg_res2 <- lm(data = piaac, logwage ~ educ + gender + age + I(age^2) + occupation)

modelsummary(list(reg_res1, reg_res2),
         stars = TRUE, 
         coef_map = c("gender男性" = "男性（vs. 女性）",
                      "educ高校" = "高校（vs. 中学）",
                      "educ短大高専" = "短大高専（vs. 中学）",
                      "educ大学大学院" = "大学大学院（vs. 中学）",
                      "age" = "年齢",
                      "I(age^2)" = "年齢2乗",
                      "occupation専門職" = "専門職（vs. 管理職）",
                      "occupation技術職・准専門職" = "技術職・准専門職（vs. 管理職）",
                      "occupation事務補助" = "事務補助（vs. 管理職）",
                      "occupationサービス・販売" = "サービス・販売（vs. 管理職）",
                      "occupation農林漁業" = "農林漁業（vs. 管理職）",
                      "occupation技能工" = "技能工（vs. 管理職）",
                      "occupation設備・機械運転・組立" = "設備・機械運転・組立（vs. 管理職）",
                      "occupation単純作業" = "単純作業（vs. 管理職）",
                      "(Intercept)" = "切片"),
         gof_map = c("nobs", "r.squared"))
```

年齢と性別を統制したうえでの学歴の係数が、職業を考慮することによってどの程度変わるのかをみる。これをみると、Model 1と比べて、職業を一定としたModel 2では学歴の係数がかなり小さくなる。学歴が高いと賃金が高いという関連のかなりの部分が、職業分布の違いによって生じているようだということを、2つのモデルの学歴の係数の違いから読み取ることができる。

このように、回帰分析を使う際には、どのような効果を知りたいのかを意識して、何を交絡要因として統制すべきなのか、何を媒介要因と位置づけるのかを考えながら分析することが大事である。

従属変数に対数を用いた場合には、係数の大きさが実質的にどれくらいであるのかを$\exp(\beta) - 1$を計算して求めるとよい。くわしくは[前章](#regression_basic_log)を参照のこと。`broom::tidy()`を用いることで、この計算をスムーズに行うことができる。先のModel 2の結果を変換してみよう。

```{r}
reg_res2 %>% 
  tidy() %>% 
  mutate(estimate_exp = exp(estimate) - 1)
```

```{r, include=FALSE, echo=FALSE}
reg_res2_tidy <- reg_res2 %>% 
  tidy() %>% 
  mutate(estimate_exp = (exp(estimate) - 1) * 100) %>% 
  mutate(estimate_exp = round(estimate_exp, 1)) %>% 
  filter(term == "educ大学大学院")
```

この結果は、例えば学歴（とくに大学大学院卒）の結果であれば、性別・年齢・職業を一定としてもなお、大学大学院卒の人は中学卒の人と比べて`r reg_res2_tidy$estimate_exp[1]`%賃金が高いということを意味している。

## 結果をファイルに書き出す

前章の[結果をファイルに書き出す](#regression_basic_export)を参照。念のため、再確認しておくと、 `flextable`パッケージを読みこんでおいた状態で、上記の`modelsummary()`のコードに`output = "xxx.docx"`というようなオプションをつけることで、wordファイルに結果を書き出すことができる。

```{r}
modelsummary(list(reg_res1, reg_res2),
         stars = TRUE, 
         coef_map = c("gender男性" = "男性（vs. 女性）",
                      "educ高校" = "高校（vs. 中学）",
                      "educ短大高専" = "短大高専（vs. 中学）",
                      "educ大学大学院" = "大学大学院（vs. 中学）",
                      "age" = "年齢",
                      "I(age^2)" = "年齢2乗",
                      "occupation専門職" = "専門職（vs. 管理職）",
                      "occupation技術職・准専門職" = "技術職・准専門職（vs. 管理職）",
                      "occupation事務補助" = "事務補助（vs. 管理職）",
                      "occupationサービス・販売" = "サービス・販売（vs. 管理職）",
                      "occupation農林漁業" = "農林漁業（vs. 管理職）",
                      "occupation技能工" = "技能工（vs. 管理職）",
                      "occupation設備・機械運転・組立" = "設備・機械運転・組立（vs. 管理職）",
                      "occupation単純作業" = "単純作業（vs. 管理職）",
                      "(Intercept)" = "切片"),
         gof_map = c("nobs", "r.squared"),
         output = "results/regression_multiple.docx")
```

ところで、上記の表のように独立変数が増えてくると、なんだか表が縦に長くて見にくいなあと思うかもしれない。そうした場には、次のように書くことで、標準誤差の値を係数の右側に並べて表記でき、表の縦の長さを短くできる。

```{r}
modelsummary(list(reg_res1, reg_res2),
         estimate = "{estimate} ({std.error}){stars}", # 係数（半角スペース）(標準誤差)星印、となるように表記するオプション
         statistic = NULL, #「2行目」の表記を省略するオプション。
         coef_map = c("gender男性" = "男性（vs. 女性）",
                      "educ高校" = "高校（vs. 中学）",
                      "educ短大高専" = "短大高専（vs. 中学）",
                      "educ大学大学院" = "大学大学院（vs. 中学）",
                      "age" = "年齢",
                      "I(age^2)" = "年齢2乗",
                      "occupation専門職" = "専門職（vs. 管理職）",
                      "occupation技術職・准専門職" = "技術職・准専門職（vs. 管理職）",
                      "occupation事務補助" = "事務補助（vs. 管理職）",
                      "occupationサービス・販売" = "サービス・販売（vs. 管理職）",
                      "occupation農林漁業" = "農林漁業（vs. 管理職）",
                      "occupation技能工" = "技能工（vs. 管理職）",
                      "occupation設備・機械運転・組立" = "設備・機械運転・組立（vs. 管理職）",
                      "occupation単純作業" = "単純作業（vs. 管理職）",
                      "(Intercept)" = "切片"),  
         gof_map = c("nobs", "r.squared") )
```

結果をwordファイルに出力するときには、今までと同様、outputオプションをつける。
